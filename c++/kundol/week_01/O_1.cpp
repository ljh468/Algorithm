#include <bits/stdc++.h>
using namespace std;  

/**
 * 2와 5로 나누어 떨어지지 않는 정수 n(1 ≤ n ≤ 10000)가 주어졌을 때,
 * 각 자릿수가 모두 1로만 이루어진 n의 배수를 찾는 프로그램을 작성하시오.
 * 입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있고, n이 주어진다.
 * 각 자릿수가 모두 1로만 이루어진 n의 배수 중 가장 작은 수의 자리수를 출력
 * 
 * 모듈러 연산의 분배법칙:
 * (a + b) % n = [(a % n) + (b % n)] % n
 * (a * b) % n = [(a % n) * (b % n)] % n
 */

/**
 * cnt = (cnt * 10) + 1; 증명
 * 
 * = ((cnt * 10 + 1) * 10 + 1) % n
 * = ((cnt * 10 + 1) % n * 10 + 1) & n
 * 
 * ==> 이게 맞는거 아니야?
 * = ((cnt * 10 + 1) % n * 10 % n + 1 % n) % n
 * 
 * ==> 이 공식이 성립하려면?
 * (a * b * c) % n = (a % n * b + c) % n
 * 
 * ==> 증명해야 하는 것 1
 * a % n = (a % n) % n
 * "a % n"이 가지는 숫자의 범위는 "0 ~ n - 1" 까지임
 * (0 ~ n - 1) % n = (0 ~ n - 1) 은 동일하므로 성립이 됨
 * 
 * ==> 증명해야 하는 것 2
 * (a % n * b) % n = (a * b) & n
 * (a % n % n * b % n) & n = (a % n * b % n) % n
 * (a % n % n) == (a % n) 이 같으므로 성립이 됨
 */
int n;
int main(){ 
	while(cin >> n){
		int cnt = 1, ret = 1; 
		while(true){
			if(cnt % n == 0){
				cout << ret << '\n';
				break;
			}else{
				cnt = (cnt * 10) + 1;
				// 모듈러 연산의 분배법칙에 의해 이전에 모듈러 연산을 해도 ok
				// cnt = (cnt % n * 10 % 2) + 1 도 동일
				cnt %= n; 
				cout << cnt << "\n";
				ret++;
			}
		} 
	}  
	return 0;
} 