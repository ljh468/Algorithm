#include<bits/stdc++.h>
using namespace std;

/**
 * 문제 분석 :
 * 흑백 영상을 압축하여 표현하는 데이터 구조로 쿼드 트리(Quad Tree)라는 방법이 있다.
 * 흰 점을 나타내는 0과 검은 점을 나타내는 1로만 이루어진 영상(2차원 배열)에서
 * 같은 숫자의 점들이 한 곳에 많이 몰려있으면, 쿼드 트리에서는 이를 압축하여 간단히 표현
 * 주어진 영상이 모두 0으로만 되어 있으면 압축 결과는 "0"이 되고,
 * 모두 1로만 되어 있으면 압축 결과는 "1"이 된다.
 * 만약 0과 1이 섞여 있으면 전체를 한 번에 나타내지를 못하고,
 * 왼쪽 위, 오른쪽 위, 왼쪽 아래, 오른쪽 아래, 이렇게 4개의 영상으로 나누어 압축
 * 하게 되며, 이 4개의 영역을 압축한 결과를 차례대로 괄호 안에 묶어서 표현
 * 
 * 아이디어 :
 * 못풀었음(문제를 이해못함) -> 강의 참고함
 * 분할 정복 알고리즘을 사용하여 2차원 배열을 사분면으로 나누고,
 * 이를 쿼드트리(quadtree)로 표현해야함
 * 
 * 0 또는 1인지를 파악하고 Z자로 탐색하는 반복로직이 존재 (재귀)
 */

/*
입력값 :
8
11110000
11110000
00011100
00011100
11110000
11110000
11110011
11110011
*/

/*
출력값 :
((110(0101))(0010)1(0001))
*/

int n; 
string s;   
char a[104][104];

string quard(int y, int x, int size) {
    // 종료 조건:
    // 사이즈가 1인 경우(더이상 쪼개지지 않을때), 단일 값 반환
    if (size == 1) {
		    // char 배열을 string으로 변환
        return string(1, a[y][x]);
    }
    
    char b = a[y][x];  // 현재 사분면의 시작 위치 값을 저장
    string ret = "";   // 결과를 저장할 문자열
    
    // 현재 사분면의 모든 셀을 확인
    for (int i = y; i < y + size; i++) {
        for (int j = x; j < x + size; j++) {
            // 만약 하나라도 다른 값이 있다면
            if (b != a[i][j]) {
                // 사분면을 4개의 하위 사분면으로 나누고 재귀 호출
                ret += '(';
                ret += quard(y, x, size / 2);                     // 왼쪽 위
                ret += quard(y, x + size / 2, size / 2);          // 오른쪽 위
                ret += quard(y + size / 2, x, size / 2);          // 왼쪽 아래
                ret += quard(y + size / 2, x + size / 2, size / 2); // 오른쪽 아래
                ret += ')';
                return ret;  // 결과 반환
            }
        } 
    }
    
    // 현재 사분면의 모든 값이 같다면 해당 값을 반환
    return string(1, a[y][x]);
}

int main() {
    // 배열의 크기 입력
    // 배열의 각 행을 입력 받아 2차원 배열에 저장
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> s; 
        for (int j = 0; j < n; j++) {
            a[i][j] = s[j];
        }
    }

    // 쿼드트리 변환 결과 출력 (start x, start y, size)
    cout << quard(0, 0, n) << '\n'; 
    return 0; 
}