# 구현(Implementation) 이란?
# 머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정
# 풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제를 지칭
# 1. 알고리즘은 간단하나 코드가 길어지는 문제 2. 실수연산을 다루고, 특정소수점 자리까지 출력하는 문제
# 3. 문자열을 특정한 기준에 따라서 끊어 처리해야 하는 문제 4. 적절한 라이브러리를 찾아서 사용해야 하는 문제

# 일반적으로 알고리즘 문제에서의 2차원 공간은 행렬(Matrix)의 의미

for i in range(5):
    for j in range(5):
        print('(', i, ',', j, ')', end=' ')
    print()

# 시뮬레이션 및 완전 탐색 문제에서는 2차원 공간에서의 방향 벡터가 자주 활용됨

# 방향 벡터
# 동, 북, 서, 남
dx = [0, -1, 0, 1]
dy = [1, 0, -1, 0]

# 현재 위치
x, y = 2, 2

for i in range(4):
    # 다음위치
    nx = x + dx[i]
    ny = x + dy[i]

print("#######################################")

## 예제 00
# 여행가 A는 N*N크기의 정사각형 공간 위에 있습니다. 가장 왼쪽위 좌표는 (1, 1)이며, 가장 오른쪽아래 좌표는 (N, N)
# 여행가는 상, 하, 좌, 우 이동할수 있으며 항상 시작좌표는 (1, 1) 이다
# L : 왼쪽, R: 오른쪽, U: 위, D: 아래
# 이때 여행가 A가 (N * N) 크기의 정사각형 공간을 벗어나는 움직임은 무시됨
# ex) (1, 1)위치에서 L 혹은 U를 만나면 무시됨
# 여행가를 계획서 대로 움직여서 위치를 출력하시오

# 입력예시 : 5, 입력예시 : R R R U D D
# 출력예시 : 3 4

# N 입력받기
# n = int(input())
n = 5
# x, y = 1, 1
plans = ['L', 'R', 'U', 'D']
# plans = input().split()
# L, R, U, D에 따른 이동 방향
dx = [0, 0, -1, 1]  # 행
dy = [-1, 1, 0, 0]  # 열
move_types = ['L', 'R', 'U', 'D']

# 이동 계획을 하나씩 확인하기
for plan in plans:
    # 이동후 좌표 구하기
    for i in range(len(move_types)):
        if plan == move_types[i]:
            nx = x + dx[i]
            ny = y + dy[i]

    # 공간을 벗어나는 경우 무시
    if nx < 1 or ny < 1 or nx > n or ny > n:
        continue
    # 이동 수헹
    x, y = nx, ny

print(x, y)

## 예제 01
# 정수 N이 입력되면 00시 00분 00초부터 N시 59분 59초까지의 모든 시각중에서 3이 하나라도 포함되는
# 모든 경우의 수를 구하는 프로그램을 작성하시오.
# 예를 들어 1을 입력했을때 다음은 3이 하나라도 포함되어 있으므로 세어야 하는 시각입니다.
# 세어야 하는 시각 : 1. 00시00분03초 2. 00시13분30초
# 입력예시 : 5
# 출력예시 : 11475

# H 입력받기
# h = int(input())
h = 5
count = 0
for i in range(h+1):
    for j in range(60):
        for k in range(60):
            if '3' in str(i) + str(j) + str(k):
                count += 1
print(count)

# 하루는 86,400초이므로, 00시00분00초부터 23시59분59초까지의 모든 경우는 86,400가지 입니다.
# 24 * 60 * 60 = 86,400
# 따라서 단순히 시각을 1씩 증가시키면서 3이 하나라도 포함되어 있는지를 확인하면 됨 (완전탐색)

## 예제 02
# 행복왕국의 왕실 정원은 체스판과 같은 8*8 좌표 평면이다. 왕실 정원의 특정한 한 칸에 나이트가 서있음
# 나이트는 말을 타고 있기 때문에 이동을 할때는 L자 형태로만 이동할 수 있고, 정원을 나갈수는 없음
# 나이트는 특정 위치에서 2가지 경우로 이동할 수 있음
# 1. 수평으로 두칸 이동한 뒤에 수직으로 한 칸 이동하기
# 2. 수직으로 두칸 이동한 뒤에 수평으로 한 칸 이동하기
# 이처럼 8 * 8좌표 평면상에서 나이트의 위치가 주어졌을때 나이트가 이동할 수 있는 경우의 수를 출력
# 행 위치는 1부터 8, 열 위치는 a부터 h
# ex) c2에 있을때 이동할 수 있는 경우의 수는 6가지임

# 현재 나이트의 위치 입력받기
# input_data = input()
input_data = "c2"
row = int(input_data[1])
column = int(ord(input_data[0])) - int(ord('a')) + 1 # 문자를 아스키코드를 이용하여 숫자로 변환
print(ord('a'))
print(ord('A'))
print(chr(97))
print(chr(65))

# 나이트가 이동할 수 있는 8가지 방향 정의 (방향벡터 8가지)
steps = [(-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2), (-1, 2), (-2, 1)]

# 8가지 방향에 대하여 각 위치로 이동이 가능한지 확인
result = 0
for step in steps:
    # 이동하고자 하는 위치 확인
    next_row = row + step[0]
    next_column = column + step[1]
    # 해당 위치로 이동이 가능하다면 카운트 증가
    if next_row >= 1 and next_row <= 8 and next_column >= 1 and next_row <= 8 :
        result += 1

print(result)


# 나이트의 8가지 경로를 하나씩 확인하며 각 위치로 이동이 가능한지 확인함
# 리스트를 이용하여 8가지 방향에 대한 방향 벡터를 정의함