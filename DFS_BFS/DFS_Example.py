## 예제 00)
# 음료수 얼려 먹기
# N * M 크기의 얼음 틀이 있습니다, 구멍이 뚫려있는 부분은 0, 칸막이가 존재하는 부분은 1로 표시됨
# 구멍이 뚫려있는 부분끼리 상, 하, 좌, 우 붙어있는 경우 서로 연결되어 있는것으로 간주합니다.
# 이때 얼음 틀의 모양이 주어졌을대 생성되는 총 아이스크림의 개수를 구하는 프로그램을 작성하시오.
# 입력 예시 : 4, 5
#           00110
#           00011
#           11111
#           00000
# 출력예시 : 3

# 이 문제는 DFS or BFS로 해결할 수 있음, 일단 얼음을 얼릴수 있는 공간이 상,하,좌,우로 연결되어 있다고 표현할 수 있으므로
# 그래프의 형태로 모델링함

# DFS를 활용한 알고리즘
# 1. 특정한 지점의 주변 상,하,좌,우를 살펴본 뒤에 주변지점 중에서 값이 '0'이면서 아직 방문하지 않은 지점이 있다면 해당 지점을 방문함
# 2. 방문한 지점에서 다시 상,하,좌,우를 살펴보면서 방문을 진행하는 과정을 반복하면,연결된 모든 지점을 방문할 수 있음
# 3. 모든 노드에 대하여 1~2번 과정을 반복하며, 방문하지 않은 지점의 수를 카운트함

# 풀이
# DFS로 특정 노드를 방문하고 연결된 모든 노드들도 방문
def dfs(x, y):
    # 주어진 범위를 벗어나는 경우에는 즉시 종료
    if x <= -1 or x >= n or y <= -1 or y >= m:
        return False
    # 현재 노드를 아직방문하지 않았다면
    if graph[x][y] == 0:
        # 해당 노드 방문처리
        graph[x][y] = 1
        # 상, 하, 좌, 우의 위치들도 모두 재귀적으로 호출
        dfs(x-1, y)
        dfs(x, y-1)
        dfs(x+1, y)
        dfs(x, y+1)
        return True
    return False

# N, M을 공백을 기준으로 구분하여 입력받기
# n, m = map(int,input().split()) # 예시 : 4,5
n, m = 4,5
# 2차원 리스트의 맵정보 입력받기
# graph = []
# for i in range(n):
#     graph.append(list(map(int,input()))) # 00110, 00011, 11111, 00000
graph = [[0, 0, 1, 1, 0], [0, 0, 0, 1, 1], [1, 1, 1, 1, 1], [0, 0, 0, 0, 0]]
print(graph)
# 모든 노드(위치)에 대하여 음료수 채우기
result = 0
for i in range(n):
    for j in range(m):
        # 현재위치에서 DFS수행
        print(dfs(i,j))
        if dfs(i,j) == True:
            result +=1
print(result) # 정답 출력

# TIP
# 1. 현재 주어진 맵은 이중배열로 인식
# 2. DFS 개념을 정용하여 특정지점에서 부터 방문을 시작하자
# 3. 방문한 지점은 얼음으로 만들어서 방문하지 못하도록 인식
# 4. 방문한다는 개념을 가질때 DFS 재귀를 넣어서 연결된다는 조건을 만족하면 True
# 5. DFS 재귀의 끝내는 마무리 조건을 False 로 넣어서 재귀 탈출 조건을 만들어줌
